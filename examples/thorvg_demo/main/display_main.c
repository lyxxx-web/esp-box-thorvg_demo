/*
 * SPDX-FileCopyrightText: 2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: CC0-1.0
 */

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_err.h"
#include "esp_check.h"
#include "esp_timer.h"
#include "esp_lcd_panel_ops.h"

#include "bsp/esp-bsp.h"
#include "thorvg_capi.h"
#include "assets_generate.h"

static const char *TAG = "ThorVG";

static void example_play_tick_new(esp_timer_handle_t *tm);
static void example_play_tick_del(esp_timer_handle_t tm);
static uint32_t example_play_tick_get(void);
static uint32_t example_play_tick_elaps(uint32_t prev_tick);

static void example_loop_task(void *arg);
static esp_err_t example_create_lottie(int index);
static void example_argb888_to_rgb565(uint8_t *in, uint16_t *out, int width, int height);
static const char *example_get_file_extension(const char* filename);
static bool example_notify_refresh_done(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_io_event_data_t *edata, void *user_ctx);

/* SPIFFS mount root */
#define FS_MNT_PATH             BSP_SPIFFS_MOUNT_POINT

#define LOTTIE_SIZE_HOR         (BSP_LCD_H_RES)
#define LOTTIE_SIZE_VER         (BSP_LCD_V_RES)

#define EXPECTED_FPS            (20)

static mmap_assets_handle_t asset_handle;
static SemaphoreHandle_t refresh_finish = NULL;

static uint32_t sys_time = 0;
static volatile uint8_t tick_irq_flag;
static esp_lcd_panel_io_handle_t io_handle = NULL;
static esp_lcd_panel_handle_t panel_handle = NULL;
static int tvg_size = 240;
static int flag = 0;
void app_main(void)
{
    const mmap_assets_config_t config = {
        .partition_label = "storage",
        .checksum = MMAP_CHECKSUM, //generated by esp_mmap_assets
        .max_files = TOTAL_MMAP_FILES,
    };
    ESP_ERROR_CHECK(mmap_assets_new(&config, &asset_handle));

    /* Initialize display */
    const bsp_display_config_t bsp_disp_cfg = {
        .max_transfer_sz = (BSP_LCD_H_RES * BSP_LCD_V_RES) * sizeof(uint16_t),
    };
    bsp_display_new(&bsp_disp_cfg, &panel_handle, &io_handle);

    refresh_finish = xSemaphoreCreateBinary();
    assert(refresh_finish);

    const esp_lcd_panel_io_callbacks_t cbs = {
        .on_color_trans_done = example_notify_refresh_done,
    };
    esp_lcd_panel_io_register_event_callbacks(io_handle, &cbs, NULL);

    esp_lcd_panel_disp_on_off(panel_handle, true);
    bsp_display_backlight_on();

    BaseType_t res = xTaskCreate(example_loop_task, "thorvg task", 60 * 1024, NULL, 5, NULL);
    if (res != pdPASS) {
        ESP_LOGE(TAG, "Create thorvg task fail!");
    }
}

void example_loop_task(void *arg)
{
    //int index = 0;
    while (1) {
        example_create_lottie(1);

        vTaskDelay(pdMS_TO_TICKS(1));
    }
    vTaskDelete(NULL);
}

static esp_err_t example_create_lottie(int index)
{
    esp_err_t ret = ESP_OK;
    Tvg_Result tvg_engine = TVG_RESULT_UNKNOWN;
    Tvg_Result tvg_res = TVG_RESULT_SUCCESS;

    uint32_t *canvas_buf = NULL;
    uint8_t *lottie_buf = NULL;

    Tvg_Animation *animation = NULL;
    Tvg_Canvas *canvas = NULL;
    esp_timer_handle_t play_timer = NULL;

    example_play_tick_new(&play_timer);

    canvas_buf = heap_caps_aligned_calloc(64, LOTTIE_SIZE_HOR * LOTTIE_SIZE_VER * sizeof(uint32_t), sizeof(uint8_t), MALLOC_CAP_SPIRAM);
    ESP_GOTO_ON_FALSE(canvas_buf, ESP_ERR_NO_MEM, err, TAG, "Error malloc canvas buffer");

    tvg_engine = tvg_engine_init(TVG_ENGINE_SW, 0);
    ESP_GOTO_ON_FALSE(tvg_engine == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_engine_init failed");

    canvas = tvg_swcanvas_create();
    ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_engine_init failed");

    tvg_res = tvg_swcanvas_set_target(canvas, canvas_buf, LOTTIE_SIZE_HOR, LOTTIE_SIZE_HOR, LOTTIE_SIZE_VER, TVG_COLORSPACE_ARGB8888);
    ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_engine_init failed");

    /* shape rect */
    Tvg_Paint *paint = tvg_shape_new();
    ESP_GOTO_ON_FALSE(paint, ESP_ERR_INVALID_STATE, err, TAG, "tvg_shape_new failed");

    tvg_res = tvg_shape_append_rect(paint, 0, 0, LOTTIE_SIZE_HOR, LOTTIE_SIZE_HOR, 0, 0);
    ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_shape_append_rect failed");

    tvg_res = tvg_shape_set_fill_color(paint, 0x00, 0x00, 0x00, 255);
    ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_shape_set_fill_color failed");

    tvg_res = tvg_canvas_push(canvas, paint);
    ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_push failed");

    tvg_res = tvg_canvas_draw(canvas);
    ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_draw failed");

    tvg_res = tvg_canvas_sync(canvas);
    ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_sync failed");

    example_argb888_to_rgb565((uint8_t *)canvas_buf, (uint16_t *)canvas_buf, LOTTIE_SIZE_HOR, LOTTIE_SIZE_VER);
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LOTTIE_SIZE_HOR, LOTTIE_SIZE_VER, canvas_buf);

    /* tvg Lottie */
    animation = tvg_animation_new();
    ESP_GOTO_ON_FALSE(animation, ESP_ERR_INVALID_STATE, err, TAG, "tvg_animation_new failed");

    Tvg_Paint *picture = tvg_animation_get_picture(animation);
    ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_animation_get_picture failed");

    ESP_LOGI(TAG, "load[%dKB]:[%s]", mmap_assets_get_size(asset_handle, index) / 1000, mmap_assets_get_name(asset_handle, index));
    const uint32_t len = mmap_assets_get_size(asset_handle, index);
    lottie_buf = malloc(len + 1);
    const uint8_t *p = (const uint8_t *)mmap_assets_get_mem(asset_handle, index);
    memcpy(lottie_buf, p, len);
    lottie_buf[len] = '\0';

    const char *ext = example_get_file_extension(mmap_assets_get_name(asset_handle, index));
    tvg_res = tvg_picture_load_data(picture, (const char *)lottie_buf, len, ext, false);
    ESP_GOTO_ON_FALSE(picture, ESP_ERR_INVALID_STATE, err, TAG, "tvg_picture_load_data failed");

    while (1) {
        tvg_res = tvg_picture_set_size(picture, tvg_size, tvg_size);
        ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_picture_set_size failed");

        tvg_res = tvg_canvas_push(canvas, picture);
        ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_push failed");

        if (NULL == strstr(mmap_assets_get_name(asset_handle, index), ".json")) {
            tvg_res = tvg_canvas_draw(canvas);
            ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_draw failed");

            tvg_res = tvg_canvas_sync(canvas);
            ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_sync failed");

            example_argb888_to_rgb565((uint8_t *)canvas_buf, (uint16_t *)canvas_buf, LOTTIE_SIZE_HOR, LOTTIE_SIZE_VER);
            esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LOTTIE_SIZE_HOR, LOTTIE_SIZE_VER, canvas_buf);

            if (tvg_size > 80 && !flag) {
                tvg_size -= 10;
            } else {
                flag = 1;
                tvg_size += 10;
                if (tvg_size == 240) {
                    flag = 0;
                }
            }
        }
        vTaskDelay(pdMS_TO_TICKS(20));
    }

    //     else {
    //     float f_total;
    //     float f = 0;
    //     tvg_res = tvg_animation_get_total_frame(animation, &f_total);
    //     ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_animation_get_total_frame failed");
    //     ESP_GOTO_ON_FALSE((f_total != 0.0f), ESP_ERR_INVALID_STATE, err, TAG, "tvg_animation_get_total_frame failed");

    //     uint32_t time_busy = 0;
    //     uint32_t anim_start = example_play_tick_get();

    //     while (f < f_total) {
    //         uint32_t frame_start = example_play_tick_get();

    //         tvg_res = tvg_animation_get_frame(animation, &f);
    //         if (++f > f_total) {
    //             break;
    //         }
    //         tvg_res = tvg_animation_set_frame(animation, f);
    //         ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_animation_set_frame failed");

    //         tvg_res = tvg_canvas_update(canvas);
    //         ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_update failed");

    //         tvg_res = tvg_canvas_draw(canvas);
    //         ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_draw failed");

    //         tvg_res = tvg_canvas_sync(canvas);
    //         ESP_GOTO_ON_FALSE(tvg_res == TVG_RESULT_SUCCESS, ESP_ERR_INVALID_STATE, err, TAG, "tvg_canvas_sync failed");

    //         example_argb888_to_rgb565((uint8_t *)canvas_buf, (uint16_t *)canvas_buf, LOTTIE_SIZE_HOR, LOTTIE_SIZE_VER);
    //         esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LOTTIE_SIZE_HOR, LOTTIE_SIZE_VER, canvas_buf);

    //         time_busy += example_play_tick_elaps(frame_start);
    //         xSemaphoreTake(refresh_finish, portMAX_DELAY);

    //         uint32_t elaps_frame = example_play_tick_elaps(frame_start);
    //         if (elaps_frame < (1000 / EXPECTED_FPS)) {
    //             vTaskDelay(pdMS_TO_TICKS((1000 / EXPECTED_FPS) - elaps_frame));
    //         } else {
    //             vTaskDelay(pdMS_TO_TICKS(1));
    //         }
    //     }
    //     uint32_t elaps_anim = example_play_tick_elaps(anim_start);
    //     ESP_LOGI(TAG, "CPU:%" PRIu32 "%%, FPS:%d/%d", (time_busy * 100 / elaps_anim), (int)(1000 * f_total / elaps_anim), EXPECTED_FPS);
    // }

err:
    if (animation) {
        tvg_animation_del(animation);
    }
    if (canvas) {
        tvg_canvas_destroy(canvas);
    }
    if (TVG_RESULT_SUCCESS == tvg_engine) {
        tvg_engine_term(TVG_ENGINE_SW);
    }
    if (play_timer) {
        example_play_tick_del(play_timer);
    }

    if (canvas_buf) {
        free(canvas_buf);
    }

    if (lottie_buf) {
        free(lottie_buf);
    }

    return ret;
}

static void example_argb888_to_rgb565(uint8_t *in, uint16_t *out, int width, int height)
{
    int numPixels = width * height;
    for (int i = 0; i < numPixels; i++) {
        uint8_t r = in[i * 4 + 2];
        uint8_t g = in[i * 4 + 1];
        uint8_t b = in[i * 4 + 0];

        uint16_t r565 = (r >> 3) & 0x1F;
        uint16_t g565 = (g >> 2) & 0x3F;
        uint16_t b565 = (b >> 3) & 0x1F;

        uint16_t rgb565Value = (r565 << 11) | (g565 << 5) | b565;
        out[i] = (rgb565Value >> 8) | (rgb565Value << 8);
    }
}

static bool example_notify_refresh_done(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_io_event_data_t *edata, void *user_ctx)
{
    BaseType_t need_yield = pdFALSE;

    xSemaphoreGiveFromISR(refresh_finish, &need_yield);
    return (need_yield == pdTRUE);
}

static const char *example_get_file_extension(const char* filename)
{
    const char* ext = strrchr(filename, '.');
    return (ext && ext != filename) ? ext + 1 : "";
}

static uint32_t example_play_tick_get(void)
{
    uint32_t result;
    do {
        tick_irq_flag = 1;
        result        = sys_time;
    } while (!tick_irq_flag);

    return result;
}

static void example_play_tick_inc(void *arg)
{
    uint32_t tick_period = (uint32_t)arg;
    tick_irq_flag = 0;
    sys_time += tick_period;
}

static void example_play_tick_new(esp_timer_handle_t *tm)
{
    esp_timer_handle_t timer;

    const uint32_t time_period = 2;
    // Create and start the event sources
    const esp_timer_create_args_t timer_args = {
        .callback = &example_play_tick_inc,
        .arg = (void *)time_period,
    };

    ESP_ERROR_CHECK(esp_timer_create(&timer_args, &timer));
    ESP_ERROR_CHECK(esp_timer_start_periodic(timer, time_period * 1000));

    *tm = timer;
}

static void example_play_tick_del(esp_timer_handle_t tm)
{
    ESP_ERROR_CHECK(esp_timer_stop(tm));
    ESP_ERROR_CHECK(esp_timer_delete(tm));
}

static uint32_t example_play_tick_elaps(uint32_t prev_tick)
{
    uint32_t act_time = example_play_tick_get();

    /*If there is no overflow in sys_time simple subtract*/
    if (act_time >= prev_tick) {
        prev_tick = act_time - prev_tick;
    } else {
        prev_tick = UINT32_MAX - prev_tick + 1;
        prev_tick += act_time;
    }

    return prev_tick;
}
